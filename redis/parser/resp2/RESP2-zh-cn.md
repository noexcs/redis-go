# Redis 协议规范

Redis 客户端使用称为 **RESP**（REdis Serialization Protocol）的协议与 Redis 服务器通信。虽然该协议是专门为 Redis 设计的，但它也可以用于其他客户端-服务器软件项目。

RESP 是在以下事物之间的一种折衷：

* 实现简单。
* 解析快速。
* 人类可读。

RESP 可以序列化不同的数据类型，如整数、字符串、数组。还有一种特定的错误类型。客户端将命令发送到 Redis 服务器的形式是包含要执行命令参数的字符串数组。Redis 根据命令实现回复相应的数据类型。

RESP 是二进制安全的，由于使用前缀长度传输批量数据，因此不需要处理从一个进程传输到另一个进程的批量数据。

注意：这里概述的协议仅用于客户端-服务器通信。Redis 集群使用不同的二进制协议在节点间交换消息。

网络层
------

客户端通过创建到端口 6379 的 TCP 连接来连接 Redis 服务器。

虽然从技术上讲 RESP 并非特定于 TCP，但在 Redis 的上下文中，该协议仅用于 TCP 连接（或等效的面向流的连接，如 Unix 套接字）。

请求-响应模型
------------

Redis 接受由不同参数组成的命令。
一旦收到命令，就会进行处理并将回复发送回客户端。

这是最简单的模型，但有两种例外情况：

* Redis 支持管道（在本文档后面介绍）。因此客户端可以一次发送多个命令，并稍后等待回复。
* 当 Redis 客户端订阅了 Pub/Sub 频道时，协议会改变语义并成为 *推送* 协议，也就是说，客户端不再需要发送命令，因为服务器会在收到新消息时自动将其发送给客户端（针对客户端订阅的频道）。

除了上述两种例外情况，Redis 协议是一个简单的请求-响应协议。

RESP 协议描述
------------

RESP 协议在 Redis 1.2 中引入，但在 Redis 2.0 中成为与 Redis 服务器通信的标准方式。
这是你应该在 Redis 客户端中实现的协议。

RESP 实际上是一种支持以下数据类型的序列化协议：简单字符串、错误、整数、批量字符串和数组。

RESP 在 Redis 中作为请求-响应协议的使用方式如下：

* 客户端将命令以 RESP 批量字符串数组的形式发送给 Redis 服务器。
* 服务器根据命令实现使用其中一种 RESP 类型进行回复。

在 RESP 中，某些数据的类型取决于第一个字节：

* 对于 **简单字符串**，回复的第一个字节是 "+"
* 对于 **错误**，回复的第一个字节是 "-"
* 对于 **整数**，回复的第一个字节是 ":"
* 对于 **批量字符串**，回复的第一个字节是 "$"
* 对于 **数组**，回复的第一个字节是 "`*`"

此外，RESP 能够使用特殊变体的批量字符串或数组来表示空值，如后面所指定。

在 RESP 中，协议的不同部分总是以 "\r\n"（CRLF）结束。

<a name="simple-string-reply"></a>

RESP 简单字符串
-------------

简单字符串按以下方式编码：加号字符，后跟不能包含 CR 或 LF 字符的字符串（不允许换行），以 CRLF 结尾（即 "\r\n"）。

简单字符串用于传输非二进制安全的字符串，开销最小。例如许多 Redis 命令在成功时只回复 "OK"，作为 RESP 简单字符串，它被编码为以下 5 个字节：

    "+OK\r\n"

为了发送二进制安全的字符串，使用 RESP 批量字符串代替。

当 Redis 回复简单字符串时，客户端库应该返回从 '+' 后第一个字符开始到字符串末尾（不包括最后的 CRLF 字节）组成的字符串给调用者。

<a name="error-reply"></a>

RESP 错误
-------

RESP 有特定的错误数据类型。实际上错误与 RESP 简单字符串完全一样，但第一个字符是减号 '-' 而不是加号。简单字符串和错误在 RESP 中的真正区别在于，客户端将错误视为异常，组成错误类型的字符串就是错误消息本身。

基本格式是：

    "-Error message\r\n"

只有在发生错误时才会发送错误回复，例如如果你尝试对错误的数据类型执行操作，或者命令不存在等等。当收到错误回复时，库客户端应引发异常。

以下是错误回复的示例：

    -ERR unknown command 'foobar'
    -WRONGTYPE Operation against a key holding the wrong kind of value

"-" 之后的第一个单词，直到第一个空格或换行符，代表返回的错误类型。这只是 Redis 使用的约定，不是 RESP 错误格式的一部分。

例如，`ERR` 是通用错误，而 `WRONGTYPE` 是更具体的错误，意味着客户端尝试对错误的数据类型执行操作。这被称为 **错误前缀**，是一种允许客户端在不依赖可能随时间变化的确切消息的情况下理解服务器返回的错误类型的方式。

客户端实现可能会为不同错误返回不同类型异常，或提供通过直接向调用者提供错误名称来捕获错误的通用方法。

但是，这样的功能不应被视为至关重要，因为它很少有用，有限的客户端实现可能只是返回通用错误条件，如 `false`。

<a name="integer-reply"></a>

RESP 整数
--------

这种类型只是一个以 ":" 字节为前缀的 CRLF 结尾的整数字符串。例如 ":0\r\n" 或 ":1000\r\n" 是整数回复。

许多 Redis 命令返回 RESP 整数，如 `INCR`、`LLEN` 和 `LASTSAVE`。

返回的整数没有特殊含义，对于 `INCR` 它只是一个递增数字，对于 `LASTSAVE` 它是 UNIX 时间等等。但是，返回的整数保证在有符号 64 位整数范围内。

整数回复也广泛用于返回真或假。
例如像 `EXISTS` 或 `SISMEMBER` 这样的命令在为真时返回 1，在为假时返回 0。

像 `SADD`、`SREM` 和 `SETNX` 这样的其他命令如果实际执行了操作则返回 1，否则返回 0。

以下命令将回复整数回复：`SETNX`、`DEL`、
`EXISTS`、`INCR`、`INCRBY`、`DECR`、`DECRBY`、`DBSIZE`、`LASTSAVE`、
`RENAMENX`、`MOVE`、`LLEN`、`SADD`、`SREM`、`SISMEMBER`、`SCARD`。

<a name="nil-reply"></a>
<a name="bulk-string-reply"></a>

RESP 批量字符串
-------------

批量字符串用于表示长度最多为 512 MB 的单个二进制安全字符串。

批量字符串按以下方式编码：

* 一个 "$" 字节，后跟组成字符串的字节数（前缀长度），以 CRLF 结尾。
* 实际的字符串数据。
* 最后的 CRLF。

所以字符串 "foobar" 编码如下：

    "$6\r\nfoobar\r\n"

空字符串是：

    "$0\r\n\r\n"

RESP 批量字符串还可以使用特殊格式来表示值不存在，该格式用于表示空值。在此特殊格式中，长度为 -1，且没有数据，因此空值表示为：

    "$-1\r\n"

这被称为 **空批量字符串**。

当服务器回复空批量字符串时，客户端库 API 不应返回空字符串，而应返回空对象。
例如 Ruby 库应返回 'nil'，而 C 库应返回 NULL（或在回复对象中设置特殊标志）等等。

<a name="array-reply"></a>

RESP 数组
--------

客户端使用 RESP 数组将命令发送到 Redis 服务器。类似地，
某些返回元素集合给客户端的 Redis 命令使用 RESP 数组作为回复类型。例如 `LRANGE` 命令返回列表的元素。

RESP 数组使用以下格式发送：

* 第一个字节是 `*` 字符，后跟数组中元素数量的十进制数，再后跟 CRLF。
* 数组每个元素的附加 RESP 类型。

所以空数组就是：

    "*0\r\n"

而包含两个 RESP 批量字符串 "foo" 和 "bar" 的数组编码为：

    "*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n"

如你所见，在前缀数组的 `*<count>CRLF` 部分之后，组成数组的其他数据类型只是逐个连接。
例如三个整数的数组编码如下：

    "*3\r\n:1\r\n:2\r\n:3\r\n"

数组可以包含混合类型，元素不必是相同类型。例如，四个整数和一个批量字符串的列表可以编码如下：

    *5\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    :4\r\n
    $6\r\n
    foobar\r\n

（为清晰起见，回复分为多行）。

服务器发送的第一行是 `*5\r\n`，以指定将有五个回复。然后传输构成多批量回复项目的每个回复。

空数组的概念也存在，是指定空值的替代方式（通常使用空批量字符串，但由于历史原因我们有两种格式）。

例如当 `BLPOP` 命令超时时，它返回一个计数为 `-1` 的空数组，如下例所示：

    "*-1\r\n"

当 Redis 回复空数组时，客户端库 API 应返回空对象而不是空数组。这对于区分空列表和其他条件（例如 `BLPOP` 命令的超时条件）是必要的。

RESP 中可以有数组的数组。例如两个数组的数组编码如下：

    *2\r\n
    *3\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    *2\r\n
    +Foo\r\n
    -Bar\r\n

（为便于阅读，格式分为多行）。

上述 RESP 数据类型编码了一个包含两个元素的数组，由包含三个整数 1、2、3 的数组和包含简单字符串和错误的数组组成。

数组中的空元素
------------

数组的单个元素可能为空。这在 Redis 回复中用于表示这些元素缺失而不是空字符串。当使用带有 GET _pattern_ 选项的 SORT 命令且指定键缺失时可能发生这种情况。包含空元素的数组回复示例：

    *3\r\n
    $3\r\n
    foo\r\n
    $-1\r\n
    $3\r\n
    bar\r\n

第二个元素是空值。客户端库应返回类似这样的内容：

    ["foo",nil,"bar"]

请注意，这不是对前面章节所述内容的例外，而只是为了进一步明确协议的示例。

向 Redis 服务器发送命令
--------------------

现在你已经熟悉了 RESP 序列化格式，编写 Redis 客户端库的实现将会很容易。我们可以进一步明确客户端和服务器之间的交互方式：

* 客户端将由批量字符串组成的 RESP 数组发送给 Redis 服务器。
* Redis 服务器通过发送任何有效的 RESP 数据类型作为回复来回应客户端。

例如，典型交互可能是这样的。

客户端发送 **LLEN mylist** 命令以获取存储在键 *mylist* 中的列表长度，服务器回复整数回复，如下例所示（C: 是客户端，S: 是服务器）。

    C: *2\r\n
    C: $4\r\n
    C: LLEN\r\n
    C: $6\r\n
    C: mylist\r\n

    S: :48293\r\n

通常我们为了简化用换行符分隔协议的不同部分，但实际交互是客户端整体发送 `*2\r
$4\r
LLEN\r
$6\r
mylist\r
`。

多个命令和管道
------------

客户端可以使用同一连接发出多个命令。
支持管道，因此客户端可以在单次写入操作中发送多个命令，而无需在发出下一个命令之前读取服务器对前一个命令的回复。
所有回复都可以在最后读取。


内联命令
-------

有时你只有 `telnet` 可用，需要向 Redis 服务器发送命令。虽然 Redis 协议易于实现，但在交互式会话中使用并不理想，而且 `redis-cli` 并不总是可用。因此 Redis 还接受一种专为人类设计的特殊命令格式，称为 **内联命令** 格式。

以下是使用内联命令的服务器/客户端聊天示例
（服务器聊天以 S: 开头，客户端聊天以 C: 开头）

    C: PING
    S: +PONG

以下是返回整数的另一个内联命令示例：

    C: EXISTS somekey
    S: :0

基本上你只需在 telnet 会话中写入空格分隔的参数。
由于没有命令以在统一请求协议中使用的 `*` 开头，Redis 能够检测到这种情况并解析你的命令。

Redis 协议的高性能解析器
----------------------

虽然 Redis 协议非常人性化且易于实现，但其实现性能可以与二进制协议相当。

RESP 使用前缀长度传输批量数据，因此永远不需要扫描有效载荷中的特殊字符（如 JSON 中的情况），也不需要引用需要发送到服务器的有效载荷。

批量和多重批量长度可以通过每次字符执行单个操作同时扫描 CR 字符的代码来处理，如下 C 代码所示：

```
#include <stdio.h>

int main(void) {
    unsigned char *p = "$123\r\n";
    int len = 0;

    p++;
    while(*p != '\r') {
        len = (len*10)+(*p - '0');
        p++;
    }

    /* 现在 p 指向 '\r'，长度在 bulk_len 中。 */
    printf("%d\n", len);
    return 0;
}
```

识别第一个 CR 后，可以跳过它和后面的 LF 而不做任何处理。然后可以使用不对有效载荷进行检查的单次读取操作读取批量数据。最后，剩余的 CR 和 LF 字符会被丢弃而不做任何处理。

虽然在性能上可与二进制协议相媲美，但 Redis 协议在大多数高级语言中实现起来要简单得多，从而减少了客户端软件中的错误数量。